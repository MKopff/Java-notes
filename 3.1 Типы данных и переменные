Литералы - объявленные значения перемееных.
int x = 15; // - целочисленный литерал.
Для удобства чтения кода число(двоичное тоже) можно "разделять" с помощью "_" (даже нескольки) Начиная c JDK7. 
При компиляции "_" не учитывается. Пример: х = 123_234_567 (output: x = 123234567)


Строковые литералы в java должны начинаться и оканчиваться в одной строке. В java отсутствует спец. 
управляющий символ для продолжения строки.
В java символьные строки реализованы в виде объектов (а не массивов, как в других ЯП)


        Объявление переменной:
            Тип идентификатор [= значение] [, идентификатор = значение ...]
        
        Где тип - это примитивный тип данных, имя класса или интерфейса.

    Область видимости переменных:
        Видимость разделяется в нутри класса и методов(=функций). Переменная в каждом последующем вложенном блоке не видима 
        за пределами блока. Это явл-ся основанием для инкапсуляции. 
        Переменная в родительском блоке кода доступна для использования во вложенном блоке, но НЕ наоборот!.
        (!) Переменная создаётся при входе в её область видимости и уничтожается при выходе из неё.

        Если при объявлении переменной инициализировать её, то инициализация переменной будет повторяться при
        каждом вхождении в блок кода.

        Также нельзя объявлять переменную с тем же именем во вложенном блоке кода.


                Приведение типов. https://vertex-academy.com/tutorials/ru/prividenie-tipov-v-java/?doing_wp_cron=1578331654.8454580307006835937500
    * boolean нельзя привести к любому другому типу.
    * char м.б. приведён к целочисленным (т.к. хранит индекс любого символа)
    
        Автоматическое преобразование типов:
    Если типы обеих переменных совместимы + длина целевого типа больше длины исходного типа,
    то приведение типов выполняется автоматически. = Расширяющее преобразование.
    
        Приведение несовместных типов:
    
    Приведение числа с плавающей точкой к целочисленному: дробная часть отбрасывается (усекается),
    а не округляется, как в матане.
    *Конечно, если целочисленное значение дробного типа больше макимально вмещаемого значения контейнера целого типа, 
    то это значение будет скоращено в результате деления по модулю на диапазон целого типа (см. пример).

        Сужающее преобразование:

    Значение переменной бОльшего типа не будет преобразовано автоматически к значению меньшего типа (например, int в byte).
    Чтобы выполнить преобразование двух несовместных типов, нужно выполнить приведение (= явное преобразование типов)
    Формула: (целевой_тип) значение.
    Пример:
    int a;
    byte b;
    // ...
    b = (byte) a // Приведения значения переменной a типа int к типу byte

    *Если значение целочисленного типа больше допустимого значения byte, оно будет сведено к результату деления по модулю  
    (остаток от целочисленного деления) на диапазон типа byte.
    Например: 
    byte b; // максимальное значение byte = 256
    int i = 257;
    b = (byte) i; // поэтому значение b будет равно 1 (257%256 = 1)






    Демонстрация приведения типов:

public class Main {

    public static void main(String[] args) {
        byte b;
        int i = 257;
        double d = 323.142  ;

        System.out.println(
                "\nПреобразование типа int в тип byte.");
        b = (byte) i;
        System.out.println("i и b " + i + " " + b);

        System.out.println(
                "\nПреобразование типа double в тип int ");
        i = (int) d;
        System.out.println("d и i " + d + " " + i);


        System.out.println(
                "\nПреобразование типа double в тип byte ");
        b = (byte) d; //(323.142%256 = 67)
        System.out.println("d и b " + d + " " + b);
                }
    }

    Результат:

    Преобразование типа int в тип byte.
    i и b 257 1

    Преобразование типа double в тип int 
    d и i 323.142 323

    Преобразование типа double в тип byte 
    d и b 323.142 67


        Автоматическое продвижение типов в выражениях:

    Преобразование типов встречаетсяи в ВЫРАЖЕНИЯХ. (Когда промежуточное значение больше любого из операндов в выражении).
        Например:
    byte a = 40; //max for byte = 256
    byte b = 50;
    byte c = 100;
    int  d = a*b/c;
        *При вычислении выражений тип каждого операнда byte, short или char автоматически продвигается к типу int

    Иногда это приводит к ошибкам:

    byte b = 50;
    b = b*2; // ОШИБКА! Выражение (b*2) автоматически преведено к типу int. 
        *Так происходит всегда. Даже если результат выражения помещается в исходный тип (не int)

    Для обхода подобных ситуаций используют явное приведение типов.
    byte b = 50;
    b = (byte) (b*2); // выражение (b*2) типа int приведено к типу byte, чтобы присвоить переменной b типа byte


            Правила продвижения типов (применяемые к выражениям):

    Сначала все значения типа byte, short char приводятся к типу int.
    Затем, тип всего выражения приводится к типу long, если один из операндов относится к типу long.
    Если же один из операндов относится к типу float, то тип всего выражения продвигается к типу float.
    А если любой из операндов относится к типу double, то и результат всего вычисления относится к типу double.

    Example:

    public class Main {

    public static void main(String[] args) {
       byte b = 42;
       char c = 'a';
       short s = 1024;
       int i = 50000;
       float f = 5.67f;
       double d = .1234;

       double result = (f * b) + (i / c) - (d * s);
        System.out.println((f * b) + " + " + (i / c)
                + " - " + (d * s));
        System.out.println("result = " + result );
                }
    }

    Результат:

    238.14 + 515 - 126.3616
    result = 626.7784146484375

    Анализ:

    В первом промежуточном (f*b) тип переменной b продвигается к типу float,
    а результат вычисления этой части также относится к типу float

    В промежуточном (i/c) тип переменной c продвигается к типу int,
    а результат вычисления этого выражения относится к типу int.

    В промежуточном (d*s) тип переменной s продвигается к типу double,
    а результат вычисления этого выражения тож относится к типу double.
    

    Затем выполняются операции с полученными float, int и double.
    Результат сложения float и int относится к типу float.
    Затем разность полученного float и оставшегося double продвигается к типу double,
    Который становится окончательным типом результата всего выражения.